"use strict";
(() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b ||= {})
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };

  // lib/utils.ts
  var getUID = () => {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      var r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  };

  // lib/iframe.ts
  var taskMap = /* @__PURE__ */ new Map();
  var useConnectParent = (c) => {
    const config = {
      timeout: 5e3
    };
    Object.assign(config, c);
    const postMessage = (type, ...args) => {
      const uid = getUID();
      window.parent.postMessage(__spreadValues({
        type,
        uid
      }, args));
      return {
        uid,
        type
      };
    };
    const postPromiseMessage = (type, data) => {
      return new Promise((resolve, reject) => {
        const { uid } = postMessage(type, {
          data,
          isPromise: true
        });
        const timeout = setTimeout(() => {
          taskMap.delete(uid);
          reject(new Error("timeout"));
        }, config.timeout);
        taskMap.set(uid, (data2) => {
          clearTimeout(timeout);
          taskMap.delete(uid);
          resolve(data2);
        });
      });
    };
    const handleMessage = (evt) => {
      var _a;
      const { data, type, uid } = evt.data;
      if (taskMap.has(uid)) {
        (_a = taskMap.get(uid)) == null ? void 0 : _a({
          type,
          data
        });
      } else {
      }
    };
    const addlistenerMessage = () => {
      window.addEventListener("message", handleMessage);
    };
    const removeListenerMessage = () => {
      window.addEventListener("message", handleMessage);
    };
    return {
      addlistenerMessage,
      removeListenerMessage,
      postMessage,
      postPromiseMessage
    };
  };

  // lib/parent.ts
  var parentTaskMap = /* @__PURE__ */ new Map();
  var useConnectIframe = (c) => {
    const config = {
      timeout: 5e3
    };
    Object.assign(config, c);
    if (!config.iframe) {
      throw new Error("iframe is required");
    }
    const parent = config.iframe.contentWindow;
    const postMessage = (type, data) => {
      parent.postMessage({
        type,
        data
      });
    };
    const replyPromiseMessage = (message) => {
      window.parent.postMessage(message);
    };
    const handleMessage = (event) => {
      var _a;
      (_a = config.callback) == null ? void 0 : _a.call(config, event.data);
    };
    const listenMessage = () => {
      parent.addEventListener("message", handleMessage);
    };
    const unListenMessage = () => {
      parent.removeEventListener("message", handleMessage);
    };
    return {
      postMessage,
      listenMessage,
      unListenMessage,
      replyPromiseMessage
    };
  };
})();
